<div id="search-component" class="contenedor">
    <h4><label for="search-box">
            <span>
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-search" viewBox="0 0 16 16">
                    <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z" />
                </svg>
            </span>
            Hero Search
        </label>
    </h4>


    <!-- Cada vez que el usuario escribe en el cuadro de texto, el enlace llama a search() con el valor del cuadro de texto, un 'término de búsqueda'. 
    Los términos de búsqueda se convierten en un Observable que emite un flujo constante de términos de búsqueda -->
    <input #searchBox id="search-box" (input)="search(searchBox.value)" placeholder="Buscar" />

    <ul class="search-result">

        <!-- El *ngFor repite los objetos hero. Note que el *ngFor itera sobre una lista llamada heroes$, 
        no sobre heroes. El $ es una convención que indica que heroes$ es un Observable, no un arreglo.
        Como *ngFor no puede hacer nada con un Observable, use el carácter de filtración (|) seguido de async.
        Esto identifica el "AsyncPipe" de Angular y se suscribe automáticamente a un "Observable" para que
        no tenga que hacerlo en la clase de componente. -->

        <li *ngFor="let hero of heroes$ | async">
            <a routerLink="/detalles/{{hero.id}}">
                {{hero.name}}
            </a>
        </li>
    </ul>
</div>